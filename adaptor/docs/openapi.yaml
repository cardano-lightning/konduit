openapi: 3.1.0

servers:
  - url: http://127.0.0.1:4444

info:
  title: HTTP API Reference
  version: 1.0.0
  license:
    name: Apache-2.0
    url: https://github.com/cardano-lightning/konduit

components:
  headers: &default-headers
    Content-Type:
      schema:
        type: string
        enum:
          - "application/json;charset=utf-8"

  schemas:
    constants:
      type: object
      description: |
        A decoded (partial) view of the payment request's information, including a quote for routing the payment from the adaptor to the destination.
      required: ["key", "close_period"]
      properties:
        key:
          type: string
          format: base16
          minLength: 64
          maxLength: 64
          description: |
            Adaptor verification key.
          examples:
            - bcd1bbd2768dd2ab5682fa19f5eb8f47291ed44bb10eafc33a1da80bfb2ad225b

        close_period:
          type: integer
          format: milliseconds
          description: |
            Adaptor's (minimum) close period. That is the minimum time between a close, and an elapse. 
            This keeps the adaptor safe from losing funds.

    quote-body:
      type: object
      description: |
        A decoded (partial) view of the payment request's information, including a quote for routing the payment from the adaptor to the destination.
      required: ["key", "tag", "invoice"]
      properties:
        key:
          type: string
          format: base16
          minLength: 64
          maxLength: 64
          description: |
            Consumers verification key. Used to verify that the cheque is valid.
          examples:
            - 3b6a27bcceb6a42d62a3a8d02a6f0d73653215771de243a63ac048a18b59da29
        tag:
          type: string
          format: base16
          description: |
            The channel tag
          examples:
            - "0101010101010101"
        invoice:
          type: string
          format: bech32
          description: |
            Bolt11 invoice.

          examples:
            - lnbcrt1u1p5v9a9cpp5z28n9ewfmc40em7kayfxz5rhy9xdfq9dun6930h6hn4hl05u2e8sdqqcqzzsxqyz5vqsp58yuyhnwywacaj5wj99at99gkwzqg0vej87n25sc8f7yp3qya8jus9qxpqysgq8yp025nppkn3aty2g3g0qun7d8yfe03xtuscy0ns75wc5ny5uvuy36t2m46e2ns88g6deesj87reeuhqm5nzyard49p0a0ys6s8wm3gqrgssv5

    quote-response:
      type: object
      description: |
        The quote includes: information to build a valid cheque (amount, lock, timeout); 
        information required to route (recipient, amount in milli-satoshis, and `payment_addr`); 
        and non critical information that may be of interest to the consumer (routing fee). 
        The consumer must verify the response aligns witht their request.

      required:
        [
          "amount",
          "timeout",
          "lock",
          "recipient",
          "amount_msat",
          "payment_addr",
          "routing_fee",
        ]
      properties:
        amount:
          type: integer
          description: |
            The amount, in the channel currency (eg lovelace for ada), required to be in a cheque
            in order to cover the routing of the payment. This includes the fee.
          minimum: 0

        timeout:
          type: integer
          format: milliseconds
          description: |
            Of the cheque to service the payment.

        lock:
          type: string
          format: base16
          minLength: 64
          maxLength: 64
          description: |
            The lock on the cheque.
            Also called the "image" or "payment hash". 
            The hash digest (sha-256) of the image for the payment, kept secret by the recipient until they've received the payment.
          examples:
            - bcd1bbd2768dd2ab5682fa19f5eb8f47291ed44bb10eafc33a1da80bfb2ad225b

        recipient:
          type: string
          description:
            The hex-encoded 33-byte Lightning payment key of the recipient. This
            is `dest` in LND.
          format: base16
          minLength: 66
          maxLength: 66
          examples:
            - 02768dd2ab5682fa1bcd1bbd9f5eb8f47291edfb2ad225b44bb10eafc33a1da80b

        amount_msat:
          type: integer
          description: |
            The amount, in milli-satoshis, that appears on the invoice.
            This is `amt_msat` from LND.
          minimum: 0

        payment_addr:
          type: string
          format: base16
          minLength: 64
          maxLength: 64
          description: |
            A field inherited from LND. The name is unchanged. 
            It is not enirely clear what this value is, but it is necessary.
          examples:
            - bcd1bbd2768dd2ab5682fa19f5eb8f47291ed44bb10eafc33a1da80bfb2ad225b

        routing_fee:
          type: integer
          description: |
            According to the adaptor, the cost to route the fee on BLN, in milli-satoshis.
          minimum: 0

    pay-body:
      type: object
      description: |
        Information required to unwrite the routing of currency across the adaptor's channels, 
        as well as the information required to satisfy the recipient.
      required:
        [
          "key",
          "tag",
          "cheque_body",
          "signature",
          "recipient",
          "amount_msat",
          "payment_addr",
        ]
      properties:
        key:
          type: string
          format: base16
          minLength: 64
          maxLength: 64
          description: |
            Consumers verification key. Used to verify that the cheque is valid.
          examples:
            - 3b6a27bcceb6a42d62a3a8d02a6f0d73653215771de243a63ac048a18b59da29

        tag:
          type: string
          format: base16
          description: |
            The channel tag
          examples:
            - "0101010101010101"
        cheque_body:
          type: string
          format: base16
          description: |
            This is a cbor encoded cheque body. It would be possible to reserialise on the adaptor side, 
            but there is no real gain in doing this. 
            The adaptor verifies the cheque (cheque body and signature).
          examples:
            - 9f011903e71a00989680582031ad3d39ab3aec5d290d66afbf1efebde22219c39bba73a3ccd1216400212188ff

        signature:
          type: string
          format: base16
          description: |
            This is ed25519 signature generated by the consumer's signing key for the "tagged" cheque body message.
          examples:
            - 5840430f32cc2ebad51dd82b3c9c2c868327584bc8edf928cc082c857b4b64b665acc4257cc6b0261b0227c53d2b0f0b7e2e0a549d604834f4fb7ba91cea26d53e06

        recipient:
          type: string
          description:
            The hex-encoded 33-byte Lightning payment key of the recipient. This
            is `dest` in LND. This should be as it appears on the quote.
          format: base16
          minLength: 66
          maxLength: 66
          examples:
            - 02768dd2ab5682fa1bcd1bbd9f5eb8f47291edfb2ad225b44bb10eafc33a1da80b

        amount_msat:
          type: integer
          description: |
            The amount, in milli-satoshis, that appears on the invoice.
            This is `amt_msat` from LND.
            This should be as it appears on the quote.
          minimum: 0

        payment_addr:
          type: string
          format: base16
          minLength: 64
          maxLength: 64
          description: |
            A field inherited from LND. The name is unchanged. 
            It is not enirely clear what this value is, but it is necessary.
            This should be as it appears on the quote.
          examples:
            - bcd1bbd2768dd2ab5682fa19f5eb8f47291ed44bb10eafc33a1da80bfb2ad225b

    receipt:
      type: object
      description: |
        This is the evidence the adaptor has and can use to claim funds.
        They send this to the consumer expecting to have the unlockeds (cheques with known secrets) 
        squashed.
      required: ["squash_body", "signature", "unlockeds"]
      properties:
        squash_body:
          type: string
          format: base16
          description: |
            This is a cbor encoded squash body.

        signature:
          type: string
          format: base16
          description: |
            This is ed25519 signature generated by the consumer's signing key for the "tagged" squash body message.
          examples:
            - 5840430f32cc2ebad51dd82b3c9c2c868327584bc8edf928cc082c857b4b64b665acc4257cc6b0261b0227c53d2b0f0b7e2e0a549d604834f4fb7ba91cea26d53e06

        unlockeds:
          type: array
          items:
            type: object
            description: |
              Unlocked cheques. The secret corresponds to the lock of the cheque. 
              The consumer can verify these are valid by verifying the signature (and hash). 
              It does not rely on Consumer having a local copy.
            required: ["cheque_body", "signature", "secret"]
            properties:
              cheque_body:
                type: string
                description: |
                  As it appeared on the `/pay` body
              signature:
                type: string
                description: |
                  As it appeared on the `/pay` body
              secret:
                type: string
                format: base16
                description: |
                  sha256 hash produces the cheque body lock.
        expire:
          type: array
          items:
            type: integer
            description: |
              Indicies that appear on the squash body exclude list that can be dropped. 
              Presumably because the cheque timeout has passed.

    squash-body:
      type: object
      description: |
        Evidence that the adaptor can use to redeem funds on the L1.
        After a successful route, the consumer should squash the cheque promptly.
        Failure to do so will casue the adaptor to stop service provision.
      required: ["key", "tag", "squash_body", "signature"]
      properties:
        key:
          type: string
          format: base16
          minLength: 64
          maxLength: 64
          description: |
            Consumers verification key. Used to verify that the cheque is valid.
          examples:
            - 3b6a27bcceb6a42d62a3a8d02a6f0d73653215771de243a63ac048a18b59da29

        tag:
          type: string
          format: base16
          description: |
            The channel tag
          examples:
            - "0101010101010101"
        squash_body:
          type: string
          format: base16
          description: |
            This is a cbor encoded cheque body. It would be possible to reserialise on the adaptor side, 
            but there is no real gain in doing this. 
            The adaptor verifies the cheque (cheque body and signature).

        signature:
          type: string
          format: base16
          description: |
            This is ed25519 signature generated by the consumer's signing key for the "tagged" squash body message.
          examples:
            - 5840430f32cc2ebad51dd82b3c9c2c868327584bc8edf928cc082c857b4b64b665acc4257cc6b0261b0227c53d2b0f0b7e2e0a549d604834f4fb7ba91cea26d53e06

paths:
  /constants:
    get:
      operationId: get-constants
      security: []
      summary: Adaptor's constants
      description: |
        Adaptor's constants include: adaptor verification key and the close period.
        Both appear in the channel constants.
      responses:
        200:
          description: OK
          headers: *default-headers
          content:
            "application/json;charset=utf-8":
              schema:
                $ref: "#/components/schemas/constants"

  /quote:
    post:
      operationId: get-quote
      security: []
      summary: Quote to pay
      description: |
        Decode an invoice or other payment request, return information to the consumer required to service the payment if they choose to.
        For details on invoices, seee [bech32-encoded BOLT-11 payment request](github.com/lightning/bolts/blob/14272b1bd9361750cfdb3e5d35740889a6b510b5/11-payment-encoding.md).
        Not yet, but soon to be, supported payloads include [OpenCryptoPay](https://github.com/openCryptoPay/landingPage).

        Consumer, and partner of Adaptor, seek a quote for an invoice or equivalent payment request. 
        The request provides channel details so that the adaptor can verify such a payment would be underwritten.

        FIXME --- the quote request should involve some proof it comes from the channel partner. 
        eg the request is signed.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/quote-body"
      responses:
        200:
          description: OK
          headers: *default-headers
          content:
            "application/json;charset=utf-8":
              schema:
                $ref: "#/components/schemas/quote-response"
        400:
          description: Ill-formed request.
        401:
          description: |
            Channel identified, but squash required.
            This can happen on first request, or if the receipt becomes
            to large or too stale.
        402:
          description: Insufficient funds in channel to underwrite request.
        404:
          description: No (opened) channel with these details
        410:
          description: |
            Optional. The channel is identified but is no longer serviced.
            The consumer should close the channel if they have not already.

  /pay:
    post:
      operationId: pay
      security: []
      summary: Make payment
      description: |
        Once a consumer has received a successful quote, they are able to make payment. 
        They must construct a valid cheque with respect to the information provided in the quote. 
        Deviating from the details in the quote increases the chance of a failed transaction.

        Note that the quote and pay requests are decoupled. A quote is neither sufficient nor necessary 
        to ensure a pay is successful. It does however greatly improve the probability of success.

        A consumer should immediately squash the unlockeds using the squash endpoint.

      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/pay-body"

      responses:
        200:
          description: OK
          headers: *default-headers
          content:
            "application/json;charset=utf-8":
              schema:
                $ref: "#/components/schemas/receipt"
        400:
          description: Ill-formed request.
        401:
          description: |
            Channel identified, but squash required.
            This can happen on first request, or if the receipt becomes
            to large or too stale.
        402:
          description: Insufficient funds in channel to underwrite request.
        404:
          description: No (opened) channel with these details
        410:
          description: |
            Optional. The channel is identified but is no longer serviced.
            The consumer should close the channel if they have not already.
        504:
          description: |
            The payment has been dispatched, but has not resolved in timely manner. 
            No immediate action can be taken.
            Wait, and then submit a squash that may lead to a successful cheque being squashed, 
            or alternatively expired.

  /squash:
    post:
      operationId: squash
      security: []
      summary: Squash cheques
      description: |
        Before issuing the first cheque, 
        The adaptor has demonstrated that they have routed a payment on behalf of the Consumer. 
        The consumer squashes the successful (unlocked) cheques into a "squash". This removes time bound 
        by which the adaptor must claim their owed funds, and keeps the evidence size ~ constant, 
        as opposed to growing linerally in the number of cheques.

        The adaptor may respond with any additional unlocked cheques not yet squashed. 
        These may have occurred from a previous pay that resulted in a 504 or otherwise.

        If the consumer has lost L2 state, they can submit the zero squash. 
        The response will include the latest receipt allowing the consumer to sink state.

        FIXME - The zero squash might be public.
        It is not safe to assume the source is the consumer.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/squash-body"

      responses:
        200:
          description: OK - but this does not squash latest receipt
          headers: *default-headers
          content:
            "application/json;charset=utf-8":
              schema:
                $ref: "#/components/schemas/receipt"
        202:
          description: OK - this squashes latest
          headers: *default-headers
        400:
          description: Ill-formed request.
        404:
          description: No (opened) channel with these details
        410:
          description: |
            Optional. The channel is identified but is no longer serviced.
            The consumer should close the channel if they have not already.
