# Global variable for the node name
node := "default"
# Computed filename for the environment
dot_file := if node == "default" { ".env" } else { ".env." + node }

# Default recipe to show help
default:
    @just --list

# Internal helper to perform raw authenticated requests
# We source the specific dot_file inside the shell to ensure the correct credentials are used
_request method path data='':
    @if [ ! -f "{{dot_file}}" ]; then \
        echo "Error: Configuration file {{dot_file}} not found."; \
        exit 1; \
    fi; \
    export $(grep -v '^#' {{dot_file}} | xargs); \
    if [ -z "$LND_BASE_URL" ] || [ -z "$LND_MACAROON" ]; then \
        echo "Error: LND credentials not found in {{dot_file}}"; \
        exit 1; \
    fi; \
    curl -s -X {{method}} \
        --cacert ${LND_TLS_CERT:-/dev/null} \
        -k \
        -H "Grpc-Metadata-macaroon: $LND_MACAROON" \
        -d '{{data}}' \
        "$LND_BASE_URL{{path}}"

# Helper to encode hashes to hex
encode-hash hash:
    @if [ $(echo -n "{{hash}}" | wc -c) -eq 64 ]; then \
        echo -n "{{hash}}"; \
    else \
        echo -n "{{hash}}" | base64 -d | xxd -p -c 0; \
    fi

# --- Node Commands ---

# Check node health (shows which node is active)
health:
    @echo "Connecting to node using {{dot_file}}..."
    @just node={{node}} _request GET "/v1/getinfo" | jq '{alias: .alias, identity_pubkey: .identity_pubkey, synced: .synced_to_chain}'
    @just node={{node}} _request GET "/v1/getinfo" | jq

# --- Invoice Commands ---
# Decode a bolt11 invoice to see destination and amount
decode-invoice invoice:
    @just node={{node}} _request GET "/v1/payreq/{{invoice}}" | jq '{destination: .destination, amount_msat: .num_msat}' 

# List invoices
invoices short="":
    @just node={{node}} _request GET "/v1/invoices" | jq 'if .invoices then (if "{{short}}" == "--short" then .invoices[] | {state: .state, memo: .memo, value: .value, settled: .settled} else . end) else . end'

# Add a new invoice (amt msat)
add-invoice amt_msat memo="":
    @just node={{node}} _request POST "/v1/invoices" '{"value_msat": "{{amt_msat}}", "memo": "{{memo}}"}' | jq -r '.payment_request'

# --- Payment Commands ---

# Pay a lightning invoice
pay invoice:
    @B64_PREIMAGE=$(just node={{node}} _request POST "/v1/channels/transactions" "{\"payment_request\": \"{{invoice}}\"}" | jq -r '.payment_preimage'); \
    if [ "$B64_PREIMAGE" != "null" ]; then \
        just encode-hash $B64_PREIMAGE; \
    else \
        echo "Payment failed."; \
    fi

# V2 Payment (Streaming) - Updated to handle LND stream states
pay2 invoice:
    @echo "Paying via v2/router/send (Streaming)..."
    @RAW_RESPONSE=$(just _request POST "/v2/router/send" "{\"payment_request\": \"{{invoice}}\"}"); \
    PREIMAGE=$(echo "$RAW_RESPONSE" | jq -r 'select(.result.status == "SUCCEEDED") | .result.payment_preimage'); \
    if [ -n "$PREIMAGE" ] && [ "$PREIMAGE" != "null" ]; then \
        echo "Success! Preimage: $PREIMAGE"; \
    else \
        echo "--- PAYMENT NOT SUCCEEDED ---"; \
        echo "Could not find a SUCCEEDED status in the stream. Full response follows:"; \
        echo "$RAW_RESPONSE"; \
    fi

# List payments
payments short="":
    @just node={{node}} _request GET "/v1/payments" | jq 'if .payments then (if "{{short}}" == "--short" then .payments[] | {status: .status, hash: .payment_hash, value: .value_sat} else . end) else . end'

# --- Utility ---

# Generate a template for a specific node
# Usage: just init-node alice
init-node name:
    @echo "LND_BASE_URL=https://127.0.0.1:8080" > .env.{{name}}
    @echo "LND_MACAROON=<hex_macaroon>" >> .env.{{name}}
    @echo "LND_TLS_CERT=~/.lnd/tls.cert" >> .env.{{name}}
    @echo ".env.{{name}} created."


# The current version we are using for LND nodes
LND_VERSION := "v0-20-1-rc1"
# Where the proto files are
BASE_URL    := "https://raw.githubusercontent.com/lightningnetwork/lnd/refs/heads/" + LND_VERSION + "/lnrpc"

# Usage: just lnd-pull-all [--force] [--recursive]
[group('lnd proto')]
lnd-pull-all *flags="":
  @just lnd-pull "routerrpc/router.proto" {{flags}}

# Fetch a single proto file based on its internal path
[group('lnd proto')]
lnd-pull path *flags="":
  @just _lnd-pull {{path}} \
    $(just _parse_force {{flags}}) \
    $(just _parse_recursive {{flags}}) 

# True if --force present
@_parse_force *flags="": 
  just _parse_flag "--force" {{flags}}

# True if --recursive present
@_parse_recursive *flags="": 
  just _parse_flag "--recursive" {{flags}}

# Parses flags to determine if force is active
@_parse_flag target *flags="": 
  if [[ "{{flags}}" == *"{{target}}"* ]]; then echo "true"; else echo "false"; fi

@_lnd-pull path force recursive:
  just _lnd-pull-one {{path}} {{force}}
  just _lnd-resolve-deps {{force}} {{recursive}}

_lnd-pull-one path force:
  #!/usr/bin/env bash
  lpath="proto/{{path}}"
  url="{{BASE_URL}}/{{path}}"
  mkdir -p $(dirname ${lpath})
  if [ "{{force}}" = "true" ] || [ ! -f ${lpath} ]; then
      echo "Downloading: ${url} ";
      if ! curl -sSL --fail ${url} -o ${lpath}; then
          echo "Error: Failed to download {{path}} (curl exited with $?)" >&2
          exit 1
      fi
  else
      echo "Skipping: ${lpath} (already exists)"
  fi

# Extracts missing imports from the proto/ directory
_lnd-list-missing:
  #!/usr/bin/env bash
  # Extracts strings like 'lnrpc/rpc.proto' from import lines
  grep -rh '^import "' proto/ 2>/dev/null | sed -e 's/import "//' -e 's/";//' | sort | uniq | while read -r dep; do
      if [ ! -f "proto/$dep" ]; then
          echo "$dep"
      fi
  done

# Iteratively resolve and fetch dependencies
_lnd-resolve-deps force recursive:
    #!/usr/bin/env bash
    missing=$(just _lnd-list-missing)
    if [ -z "${missing}" ]; then
        echo "âœ… All dependencies satisfied."
        exit 0
    fi

    echo "--- Found Missing Dependencies ---"
    echo "${missing}"
    echo "----------------------------------"

    if [ "{{recursive}}" = "true" ]; then
        confirm="y"
    else
        read -p "Pull these files? [y/N] " confirm
    fi

    if [[ "${confirm}" == [yY] ]] && [[ ! ${missing} == "" ]]; then
      for file in ${missing}; do 
        just _lnd-pull-one ${file} {{force}} || exit 1;
      done
      just _lnd-resolve-deps {{force}} {{recursive}}
    else
        echo "Aborted."
    fi
